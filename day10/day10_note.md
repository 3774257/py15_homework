##本节内容
+   进程、线程的区别
+   python GIL全局解释器锁
+   线程
+   进程

##线程与进程的区别
    程序并不能单独运行，只有将程序装载到内存中，系统为它分配资源才能运行，而这种执行的程序就称之为进程。程序和进程的区别就在于：
    程序是指令的集合，它是进程运行的静态描述文本；进程是程序的一次执行活动，属于动态概念。
    在多道编程中，我们允许多个程序同时加载到内存中，在操作系统的调度下，可以实现并发地执行。这是这样的设计，大大提高了CPU的利用率。
    进程的出现让每个用户感觉到自己独享CPU，因此，进程就是为了在CPU上实现多道编程而提出的。    
    有了进程为什么还要线程？    
    进程有很多优点，它提供了多道编程，让我们感觉我们每个人都拥有自己的CPU和其他资源，可以提高计算机的利用率。很多人就不理解了，
    既然进程这么优秀，为什么还要线程呢？其实，仔细观察就会发现进程还是有很多缺陷的，主要体现在两点上：   
    进程只能在一个时间干一件事，如果想同时干两件事或多件事，进程就无能为力了。
    进程在执行的过程中如果阻塞，例如等待输入，整个进程就会挂起，即使进程中有些工作不依赖于输入的数据，也将无法执行。
    例如，我们在使用qq聊天， qq做为一个独立进程如果同一时间只能干一件事，那他如何实现在同一时刻 即能监听键盘输入、又能监听其它人给你发的消息、
    同时还能把别人发的消息显示在屏幕上呢？你会说，操作系统不是有分时么？但我的亲，分时是指在不同进程间的分时呀， 即操作系统处理一会你的qq任务，
    又切换到word文档任务上了，每个cpu时间片分给你的qq程序时，你的qq还是只能同时干一件事呀。
    再直白一点， 一个操作系统就像是一个工厂，工厂里面有很多个生产车间，不同的车间生产不同的产品，每个车间就相当于一个进程，且你的工厂又穷，
    供电不足，同一时间只能给一个车间供电，为了能让所有车间都能同时生产，你的工厂的电工只能给不同的车间分时供电，但是轮到你的qq车间时，
    发现只有一个干活的工人，结果生产效率极低，为了解决这个问题，应该怎么办呢？。。。。没错，你肯定想到了，就是多加几个工人，让几个人工人并行工作，
    这每个工人，就是线程！
    进程：
        一个程序要运行时所需的所有资源的集合
        进程是资源的集合相当于一个车间
        一个进程至少需要一个线程，这个线程称为主线程
        一个进程里可以有多个线程
        cpu cores越多，代表着你可以真正并发的线程越多
        两个进程之间的数据是完全独立的。互相不能访问。
        
        
    线程：
        一道单一的指令的控制流寄生在进程中
        单一进程里的多个线程是共享数据的
        多个线程在涉及修改同一个数据时，一定要加锁
##python GIL全局解释器锁
    无论你启多少个线程，你有多少个cpu, Python在执行的时候会淡定的在同一时刻只允许一个线程运行
##线程:
    线程是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，
    一个进程中可以并发多个线程，每条线程并行执行不同的任务。
    1、语法
        import threading
        import time
         
        def sayhi(num): #定义每个线程要运行的函数
         
            print("running on number:%s" %num)
         
            time.sleep(3)
         
        if __name__ == '__main__':
         
            t1 = threading.Thread(target=sayhi,args=(1,)) #生成一个线程实例
            t2 = threading.Thread(target=sayhi,args=(2,)) #生成另一个线程实例
         
            t1.start() #启动线程
            t2.start() #启动另一个线程
         
            print(t1.getName()) #获取线程名
            print(t2.getName())
            
        start           线程准备就绪，等待CPU调度
        setName         为线程设置名称
        getName         获取线程名称
        setDaemon       设置为后台线程或前台线程（默认）
                        如果是后台线程，主线程执行过程中，后台线程也在进行，主线程执行完毕后，后台线程不论成功与否，均停止
                        如果是前台线程，主线程执行过程中，前台线程也在进行，主线程执行完毕后，等待前台线程也执行完成后，程序停止
        join            逐个执行每个线程，执行完毕后继续往下执行，该方法使得多线程变得无意义
        
        import time
        import threading
         
         
        def run(n):
         
            print('[%s]------running----\n' % n)
            time.sleep(2)
            print('--done--')
         
        def main():
            for i in range(5):
                t = threading.Thread(target=run,args=[i,])
                t.start()
                t.join(1)
                print('starting thread', t.getName())
         
         
        m = threading.Thread(target=main,args=[])
        m.setDaemon(True) #将main线程设置为Daemon线程,它做为程序主线程的守护线程,
        #当主线程退出时,m线程也会退出,由m启动的其它子线程会同时退出,不管是否执行完任务
        m.start()
        m.join(timeout=2)
        print("---main thread done----")
    2、线程锁(互斥锁Mutex)
        一个进程下可以启动多个线程，多个线程共享父进程的内存空间，也就意味着每个线程可以访问同一份数据，
        此时，如果2个线程同时要修改同一份数据，会出现什么状况？